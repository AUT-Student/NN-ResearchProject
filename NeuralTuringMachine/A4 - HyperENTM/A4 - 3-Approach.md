# پاراگراف اول
![[Pasted image 20220701134512.png]]
در روش HyperENTM شبکه CPPN نه تنها اتصال ورودی‌ها و خروجی‌های شبکه عصبی مرتبط با وظیفه را مشخص می‌کند بلکه اینکه اطلاعات آمده از حافظه چگونه باید در شبکه ادغام شوند و چگونه اطلاعات به حافظه نوشته شوند را هم مشخص می‌کند. زیرا HyperNEAT که می‌تواند هندسه یک وظیفه را یاد بگیرد باید بتواند الگوی هندسی در اطلاعات خوانده شده از و نوشته شده به حافظه را یاد بگیرد.

![[Pasted image 20220701142731.png]]
این بخش روش HyperENTM بر روی وظیفه رونوشت‌گیری را شرح می‌دهد. در وظیفه رونوشت‌گیری از شبکه خواسته می‌شود که ...

![[Pasted image 20220701143009.png]]
به طور خلاصه شبکه ورودی‌های زیر را دارد:
* Start: ورودی که فعال می‌شود زمانی که ذخیره اعداد شروع می‌شود.
* Switch: ورودی  که فعال می‌شود زمانی که ذخیره اطلاعات باید خاتمه بیاید و شبکه باید مقادیر به خاطر سپرده شده را به یاد بیاورد.
* Bit-vector input: قبل از آنکه ورودی switch فعال شده باشد رنج این ورودی  با بیت‌هایی که بعدا می‌خواند فعال می‌شود.
* Memory read input: بردار حافظه که ماشین تورینگ در گام قبل خوانده است.

![[Pasted image 20220701143642.png]]
و خروجی‌های زیر را داریم:
* Bit-vector output: بردار بیتی که شبکه به محیط به عنوان خروجی می‌دهد. در حین فاز ورودی این خروجی نادیده گرفته می‌شود.
* Memory write output: بردار حافظه که باید در حافظه نوشته شود.
* TM controls: خروجی‌های کنترل مخصوص ماشین تورینگ. یعنی پرش، درون‌یابی و سه کنترل جابجایی (چپ، راست و توقف)

# بستر وظیفه رونوشت‌گیری
![[Pasted image 20220701144114.png]]
بستر وظیفه رونوشت‌گیری در تصویر ۲ نشان داده شده است. این بستر طراحی شده است که گره‌های ورودی بردار بیتی مختصات x را با گره‌های نوشتن بردار حافظه به اشتراک بگذارد و بالعکس با گره‌های خواندن بردار حافظه و گره‌های خروجی بردار بیتی.
به علاوه ورودی switch مختصات x اش را با خروجی پرش به اشتراک می‌گذارد بنابراین شبکه را می‌تواند وادار به پرش به حافظه‌ای کند که خواندن را از آن شروع کرده است. در این مقاله اندازه بردارهای حافظه برابر با اندازه بردار بیتی است. 
به علاوه هیچ یک از بسترها شامل گره‌های مخفی مانند آن چیزی که نشان داده شده است و ممکن است مسائل  با اندازه‌های بزرگ‌تر بدون گره مخفی را حل کند نیست.

![[Pasted image 20220701145443.png]]
**تصویر ۲**: بستر HyperENTM برای وظیفه رونوشت‌گیری
تمام ورودی‌ها در z=1 و تمام خروجی‌ها در z=-1 هستند.
قسمت a تمام گره‌ها در y=1 را نشان می‌دهد که ورودی‌های start/switch و کنترل‌های ماشین تورینگ هستند. لازم به ذکر است که مختصات x برای ورودی switch و خروجی کنترل پرش یکسان است.
قسمت b گره‌ها در y=-1‌ را نشان می‌دهد که ورودی و خروجی‌های بردار حافظه و بردار بیتی را نشان می‌دهد. گره‌های ورودی بردار بیتی مختصات x را با گره‌های  نوشتن بردار حافظه به اشتراک می‌گذارد درحالی‌که گره‌های خواندن بردار حافظه مختصات x را با گره‌های خروجی بردار بیتی به اشتراک می‌گذارد.

![[Pasted image 20220701150203.png]]
![[Pasted image 20220701150228.png]]
در کنار خروجی CPPN که وزن هر اتصال را مشخص می‌کند، هر CPPN یک خروجی تابع قدم (step-function) اضافه دارد که خروجی بیان پیوند (LEO) نامیده می‌شود. این خروجی مشخص می‌کند که آیا یک اتصال باید بیان شود یا خیر. اتصالات بالقوه برای هر ورودی در لایه‌های y=1 و y=-1 به هر خروجی در لایه‌های y=1 و y=-1‌ کوئری زده می‌شود. تعداد ورودی‌ها و خروجی‌ها در لایه y=-1 مطابق تصویر 2b وابسته به اندازه بردار بینی وظیفه رونوشت‌گیری است. که در مثال نشان‌داده شده اندازه بردار بیتی برابر با ۳ است. نورون‌ها به شکل یکنواخت در بازه‌های -۱ تا -۰.۲ در مختصات x برای ورودی‌های بردار بیتی و بردار نوشتن حافظه استفاده می‌شود و بازه ۰.۲ تا ۱ برای بردار نوشتن حافظه و خروجی بردار بیتی استفاده می‌شود. 

![[Pasted image 20220701150240.png]]
CPPN یک خروجی اضافی دارد که مشخص می‌کند که مقادیر بایاس برای هر گره در بستر به چه میزان است. این مقادیر از طریق کوئری‌های CPPN گره محور مشخص می‌شود. ( به عنوان مثال موقعیت گره مبدا و مقصد به عنوان موقعیت گره‌ای که قرار است بایاس آن تعیین شود تنظیم می‌شود.)